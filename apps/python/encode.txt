python 2.x 中字符串，uncode, encode, decode  乱码 json.dumps(), json.

1>字符串类型,  如不加前缀均为字节串, 如:
	  s1 = "abc"
	  s2 = "中国"
	  调用 len(s2) 会输出6, len() 计算的是字节码长度, 而s2的字节码长度为6

2> 加前缀u, 表示unicode 串, 如:
	  s3 = u"中国"

3> 加前缀b, 同不加前缀，为字节串:
	  s4 = b"中国"

4> 字节串的编码取决于py文件的编码

encode 与decode：
1> encode 是将uncode 转为字节串, 如:
	 ss =  u"中国"
	 s1 = ss.encode("utf-8")

2> decode 是将字节码转为uncode:
     ss = "中国"
     s1 = ss.decode("utf-8")
     
3> 关于decode( code)参数
    在python 代码文件中调用decode(code)，code 的取值取决于py文件的编码
      py文件的编码可以在文件的第一行指定， 如:
      # -*- coding:utf-8 -*-

4>  关于py文件中的头两行
      # !/usr/bin/env python
      # -*- coding: utf-8 -*-
      
      第一行告诉Linux/MacOS, 这是一个python 文件， windows 会忽略这个注释 
      第二行告诉python 解释器，以utf-8编码读取本文件


5> json.load() 中文失败
	请将文件编码改为UTF-8 (No Bom)

6> json.dumps() 失败, 如有以下语句:
   extra = {
   			"name": _name ,
   			"address": _addr,
   			"age": "15"
   			}
   	json.dumps(extra, indent=4, ensure_ascii=False,
                         sort_keys=True)
          原因： 在于ertra 中含有非utf-8编码的健或值:
          解决：
        extra = {
   			"name": _name.encode("utf-8") ,
   			"address": _addr.encode("utf-8"),
   			"age": "15"
   			}

 
	    
     
	  
	  